GENFOX E-COMMERCE — COMPLETE DATABASE SCHEMAS (MongoDB / Mongoose)
====================================================================

Copy these schemas into your backend. Each model should be in its own file
(e.g. src/models/User.ts, src/models/Product.ts, etc.).

IMPORTANT: Apply this toJSON transform to ALL schemas for consistent API responses:

  schema.set('toJSON', {
    virtuals: true,
    transform: (_doc, ret) => {
      ret.id = ret._id.toString()
      delete ret.__v
      delete ret.password   // never leak passwords
      return ret
    }
  })

====================================================================

## 1. USER

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required'],
    trim: true,
    minlength: 2,
    maxlength: 100
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: 6
  },
  role: {
    type: String,
    enum: ['USER', 'ADMIN'],
    default: 'USER'
  },
  phone: {
    type: String,
    default: ''
  },
  addresses: [{
    label: { type: String, default: 'Home' },       // Home, Work, etc.
    street: { type: String, required: true },
    city: { type: String, required: true },
    state: { type: String, required: true },
    pincode: { type: String, required: true },
    isDefault: { type: Boolean, default: false }
  }]
}, {
  timestamps: true     // createdAt, updatedAt
})

// Index
userSchema.index({ email: 1 }, { unique: true })

====================================================================

## 2. SUPPLIER

const supplierSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Business name is required'],
    trim: true
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: 6
  },
  status: {
    type: String,
    enum: ['PENDING', 'APPROVED', 'REJECTED'],
    default: 'PENDING'
  },
  phone: {
    type: String,
    default: ''
  },
  gstin: {
    type: String,
    default: ''
  },
  address: {
    type: String,
    default: ''
  },
  bankDetails: {
    accountHolderName: { type: String, default: '' },
    accountNumber: { type: String, default: '' },
    ifscCode: { type: String, default: '' },
    bankName: { type: String, default: '' }
  },
  commissionRate: {
    type: Number,
    default: 10,        // 10% platform commission
    min: 0,
    max: 100
  }
}, {
  timestamps: true
})

supplierSchema.index({ email: 1 }, { unique: true })
supplierSchema.index({ status: 1 })

====================================================================

## 3. PRODUCT

const productSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Product name is required'],
    trim: true,
    maxlength: 200
  },
  slug: {
    type: String,
    unique: true,
    sparse: true         // allows multiple nulls until pre-save generates it
  },
  description: {
    type: String,
    default: '',
    maxlength: 5000
  },
  price: {
    type: Number,
    required: [true, 'Price is required'],
    min: 0
  },
  mrp: {
    type: Number,
    default: 0,          // original MRP for showing discount
    min: 0
  },
  stock: {
    type: Number,
    required: true,
    default: 0,
    min: 0
  },
  category: {
    type: String,
    required: [true, 'Category is required'],
    enum: [
      'Electronics',
      'Fashion',
      'Home & Kitchen',
      'Beauty',
      'Sports',
      'Books',
      'Toys',
      'Grocery',
      'Mobiles',
      'Other'
    ]
  },
  images: [{
    type: String,        // Cloudinary URLs
    validate: {
      validator: (v) => v.startsWith('http://') || v.startsWith('https://'),
      message: 'Image URL must be an absolute URL'
    }
  }],
  supplierId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier',
    required: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  ratings: {
    average: { type: Number, default: 0, min: 0, max: 5 },
    count: { type: Number, default: 0 }
  }
}, {
  timestamps: true
})

// Auto-generate slug from name before saving
productSchema.pre('save', function (next) {
  if (!this.slug || this.isModified('name')) {
    const base = this.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '')
    this.slug = base + '-' + Date.now()
  }
  next()
})

productSchema.index({ supplierId: 1 })
productSchema.index({ category: 1 })
productSchema.index({ slug: 1 }, { unique: true })
productSchema.index({ name: 'text', description: 'text' })   // text search

====================================================================

## 4. ORDER

const orderSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  items: [{
    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Product',
      required: true
    },
    name: {
      type: String,
      required: true       // snapshot of product name at order time
    },
    price: {
      type: Number,
      required: true       // snapshot of price at order time
    },
    quantity: {
      type: Number,
      required: true,
      min: 1
    },
    supplierId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Supplier',
      required: true       // which supplier fulfills this item
    },
    image: {
      type: String,
      default: ''          // snapshot of first product image
    }
  }],
  total: {
    type: Number,
    required: true,
    min: 0
  },
  commission: {
    type: Number,
    default: 0,            // platform commission amount
    min: 0
  },
  status: {
    type: String,
    enum: ['PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED'],
    default: 'PENDING'
  },
  paymentMethod: {
    type: String,
    enum: ['COD', 'ONLINE', 'UPI'],
    default: 'COD'
  },
  paymentStatus: {
    type: String,
    enum: ['PENDING', 'PAID', 'REFUNDED'],
    default: 'PENDING'
  },
  address: {
    type: String,
    required: [true, 'Delivery address is required']
  },
  trackingId: {
    type: String,
    default: ''
  },

  // ── Delivery & Receipt Confirmation (COD cross-check) ──
  deliveryConfirmation: {
    supplierConfirmed: {
      type: Boolean,
      default: false           // supplier confirms delivery + cash collection
    },
    userConfirmed: {
      type: Boolean,
      default: false           // user confirms they received the order
    },
    cashCollected: {
      type: Number,
      default: 0               // amount of cash collected by supplier (COD)
    },
    deliveredAt: {
      type: Date,
      default: null            // timestamp when supplier confirmed delivery
    },
    userConfirmedAt: {
      type: Date,
      default: null            // timestamp when user confirmed receipt
    }
  }
}, {
  timestamps: true
})

orderSchema.index({ userId: 1, createdAt: -1 })
orderSchema.index({ 'items.supplierId': 1 })
orderSchema.index({ status: 1 })

====================================================================

## 5. CART

const cartSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true           // one cart per user
  },
  items: [{
    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Product',
      required: true
    },
    quantity: {
      type: Number,
      required: true,
      min: 1,
      default: 1
    }
  }]
}, {
  timestamps: true
})

cartSchema.index({ userId: 1 }, { unique: true })

====================================================================

## 6. REVIEW (optional — for future product reviews feature)

const reviewSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  productId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  rating: {
    type: Number,
    required: true,
    min: 1,
    max: 5
  },
  comment: {
    type: String,
    default: '',
    maxlength: 1000
  }
}, {
  timestamps: true
})

// One review per user per product
reviewSchema.index({ userId: 1, productId: 1 }, { unique: true })
reviewSchema.index({ productId: 1 })

====================================================================

## 7. PAYMENT / TRANSACTION (optional — for supplier payment tracking)

const transactionSchema = new mongoose.Schema({
  supplierId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier',
    required: true
  },
  orderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Order',
    required: true
  },
  type: {
    type: String,
    enum: ['ORDER_PAYMENT', 'COMMISSION_DEDUCTION', 'PAYOUT'],
    required: true
  },
  amount: {
    type: Number,
    required: true
  },
  status: {
    type: String,
    enum: ['PENDING', 'COMPLETED', 'FAILED'],
    default: 'PENDING'
  },
  description: {
    type: String,
    default: ''
  }
}, {
  timestamps: true
})

transactionSchema.index({ supplierId: 1, createdAt: -1 })
transactionSchema.index({ orderId: 1 })

====================================================================

## SUMMARY TABLE

| # | Collection    | Required? | Description                           |
|---|---------------|-----------|---------------------------------------|
| 1 | users         | YES       | End customers + admin accounts        |
| 2 | suppliers     | YES       | Supplier/seller accounts              |
| 3 | products      | YES       | Product catalog                       |
| 4 | orders        | YES       | Customer orders with item snapshots   |
| 5 | carts         | YES       | Per-user shopping carts               |
| 6 | reviews       | OPTIONAL  | Product reviews & ratings             |
| 7 | transactions  | OPTIONAL  | Supplier payment/payout records       |
| 8 | addresses     | AUTO      | Separate address collection (MongoDB) |
| 9 | categories    | OPTIONAL  | Product categories (if dynamic)       |
| 10| enquiries     | OPTIONAL  | Customer enquiries / contact form     |
| 11| payments      | OPTIONAL  | Payment records (if separate from transactions) |

====================================================================

## 8. ADDRESSES (auto-generated by MongoDB)

NOTE: MongoDB may create a separate `addresses` collection when using subdocument
arrays in the User schema. If your backend stores addresses as embedded documents
inside the User model (as defined in Schema #1), this collection is auto-generated
and you don't need to manage it separately.

If you prefer a SEPARATE addresses collection (for referencing across orders):

const addressSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  label: {
    type: String,
    default: 'Home'           // Home, Work, Office, etc.
  },
  street: {
    type: String,
    required: [true, 'Street is required']
  },
  city: {
    type: String,
    required: [true, 'City is required']
  },
  state: {
    type: String,
    required: [true, 'State is required']
  },
  pincode: {
    type: String,
    required: [true, 'Pincode is required']
  },
  isDefault: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
})

addressSchema.index({ userId: 1 })

IMPORTANT: The frontend currently manages addresses as part of the User document
(user.addresses[]). If you use a separate collection, the frontend profile page
and checkout page will need their API calls adjusted.

====================================================================

## 9. CATEGORIES (optional — for dynamic category management)

If you want the admin to manage product categories dynamically instead of the
hardcoded enum in the Product schema:

const categorySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Category name is required'],
    unique: true,
    trim: true
  },
  slug: {
    type: String,
    unique: true
  },
  description: {
    type: String,
    default: ''
  },
  image: {
    type: String,
    default: ''               // Cloudinary URL
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
})

categorySchema.index({ slug: 1 }, { unique: true })

NOTE: The frontend currently uses a hardcoded category enum in the Product schema.
If you switch to dynamic categories, you'll need to:
1. Create GET /api/categories endpoint (public, returns all active categories)
2. Update the supplier product form to load categories from API
3. Update the Product schema to reference Category by ObjectId or keep a string

====================================================================

## 10. ENQUIRIES (optional — for contact/support form)

const enquirySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required'],
    trim: true
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    lowercase: true,
    trim: true
  },
  subject: {
    type: String,
    default: ''
  },
  message: {
    type: String,
    required: [true, 'Message is required'],
    maxlength: 2000
  },
  status: {
    type: String,
    enum: ['NEW', 'READ', 'REPLIED', 'CLOSED'],
    default: 'NEW'
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null              // null for guest enquiries
  }
}, {
  timestamps: true
})

enquirySchema.index({ status: 1 })
enquirySchema.index({ createdAt: -1 })

NOTE: The frontend does NOT currently have an enquiry/contact form.
This schema is provided because the collection exists in your database.
You can build a contact page later and manage enquiries from the admin panel.

====================================================================

## 11. PAYMENTS (alternative to Transactions)

If your backend uses a `payments` collection instead of (or alongside) `transactions`:

const paymentSchema = new mongoose.Schema({
  orderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Order',
    required: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  supplierId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier',
    default: null
  },
  amount: {
    type: Number,
    required: true,
    min: 0
  },
  method: {
    type: String,
    enum: ['COD', 'ONLINE', 'UPI'],
    default: 'COD'
  },
  status: {
    type: String,
    enum: ['PENDING', 'COMPLETED', 'FAILED', 'REFUNDED'],
    default: 'PENDING'
  },
  transactionId: {
    type: String,
    default: ''               // payment gateway transaction ID
  }
}, {
  timestamps: true
})

paymentSchema.index({ orderId: 1 })
paymentSchema.index({ userId: 1 })
paymentSchema.index({ supplierId: 1 })

NOTE: This overlaps with the Transaction schema (#7). Use whichever fits your
backend architecture. The frontend supplier payments page calls:
- GET /api/supplier/payments/summary
- GET /api/supplier/payments/transactions
These can query either collection.

====================================================================

## RELATIONSHIPS

  User  ──1:N──>  Order      (userId)
  User  ──1:1──>  Cart       (userId)
  User  ──1:N──>  Review     (userId)
  User  ──1:N──>  Address    (userId, if separate collection)

  Supplier ──1:N──> Product   (supplierId)
  Supplier ──1:N──> Transaction (supplierId)

  Product ──1:N──> Review     (productId)
  Product ──N:M──> Order      (via order.items[].productId)

  Order ──1:N──> Transaction  (orderId)
  Order ──1:1──> Payment      (orderId, if separate collection)

====================================================================

## NOTES FOR BACKEND DEVELOPER

1. All passwords MUST be hashed with bcrypt before saving.
   Use a pre-save hook:
     userSchema.pre('save', async function(next) {
       if (!this.isModified('password')) return next()
       this.password = await bcrypt.hash(this.password, 12)
       next()
     })
   Apply the same to supplierSchema.

2. The Product slug is auto-generated from the name + timestamp.
   This fixes the slug_1 duplicate key error (see backend-improvements.txt #17).

3. Order items store SNAPSHOTS of product name, price, and image at order time.
   This ensures order history stays correct even if the product is later changed/deleted.

4. The commission field on Order stores the calculated platform commission.
   Formula: commission = total * (supplier.commissionRate / 100)

5. Cart should be cleared after successful order placement.

6. The Review schema is optional — implement when you add the reviews feature.

7. The Transaction schema is optional — you can derive payment data from orders
   initially, then add this when you need real payout tracking.
